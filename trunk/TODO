TODO list for DT::Set, DT::Span, and DT::SpanSet

2004-06-25

- cleanup the examples in POD that use
            return $_[0] if $_[0]->is_infinite;
  and explain when and why to use this.
- add tests for all examples given.

- add tests for using datetimes with UTC/floating (local, etc.) time zones:
    -> as parameters for next()
    -> as set elements.
- these tests should be reusable by the DateTime::Event packages.

-----------------

- Test for errors, in case the "next/previous" 
  recurrence spec is not followed (detect infinite loop).

  Give a message like:
  "A recurrence loop was detected. Check that you are using
   the latest DateTime::Event module version" 

  Or, try to detect the error and automatically
  "downgrade" DateTime::Set.

  The problem is, the infinite loops happens
  _inside_ next(). There seems to be no way to
  detect this.

- implement set( locale => .. ) in Span and SpanSet

- Add tests for new methods: DateTime::SpanSet::map / grep

- discuss functions like 
    is_infinite
    is_empty 

- implement faster DT::Set::complement(), 
  using 'function composition'

- move all 'set-specific' code to Set::Infinite::_recurrence 
  use accessors instead of structure references

- functions like before(), after(), during() might be useful
  in DT::Span
  or maybe these should be called next(), previous(), current(), closest()

- document better:
  how to transform a Span into an iterator - for example,
  get the list of days in a span

- optimization: rewrite intersection of recurrences 'previous' function

- optimization: extract start_set / end_set right from
  the data structure, if possible.

